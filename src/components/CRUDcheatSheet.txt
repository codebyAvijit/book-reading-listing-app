React CRUD Cheat Sheet (with localStorage & validation)

1️⃣ State Setup

// Main array
const [itemsArray, setItemsArray] = useState(() => {
  const stored = localStorage.getItem("itemsArray");
  return stored ? JSON.parse(stored) : [];
});

// Form state for Create or Edit
const [newItem, setNewItem] = useState({
  title: "",
  author: "",
  category: "",
  status: "",
});

// Editing state
const [editingId, setEditingId] = useState(null);
const [editingItem, setEditingItem] = useState({
  title: "",
  author: "",
  category: "",
  status: "",
});

// Validation state (optional)
const [validationErrors, setValidationErrors] = useState({});

2️⃣ Create / Add Item

const addItemHandler = (e) => {
  e.preventDefault();

  // Validation (optional)
  const errors = {};
  if (!newItem.title) errors.title = "Title required";
  if (!newItem.author) errors.author = "Author required";
  if (Object.keys(errors).length > 0) {
    setValidationErrors(errors);
    return;
  }

  const itemToAdd = { id: crypto.randomUUID(), ...newItem };
  setItemsArray(prev => {
    const updated = [...prev, itemToAdd];
    localStorage.setItem("itemsArray", JSON.stringify(updated));
    return updated;
  });

  setNewItem({ title: "", author: "", category: "", status: "" });
};


3️⃣ Read / Display Items

itemsArray.map(item =>
  editingId === item.id ? (
    // Render editable inputs
  ) : (
    // Render normal table row or list item
    <tr key={item.id}>
      <td>{item.title}</td>
      <td>{item.author}</td>
      <td>{item.category}</td>
      <td>{item.status}</td>
      <td>
        <button onClick={() => startEditing(item.id)}>Edit</button>
        <button onClick={() => deleteItem(item.id)}>Delete</button>
      </td>
    </tr>
  )
)


4️⃣ Update / Edit Item

const startEditing = (id) => {
  const itemToEdit = itemsArray.find(item => item.id === id);
  setEditingId(id);
  setEditingItem({ ...itemToEdit });
};

const saveEditHandler = () => {
  setItemsArray(prev =>
    prev.map(item =>
      item.id === editingId ? { ...item, ...editingItem } : item
    )
  );
  localStorage.setItem("itemsArray", JSON.stringify(itemsArray));
  setEditingId(null);
  setEditingItem({ title: "", author: "", category: "", status: "" });
};

const cancelEditHandler = () => {
  setEditingId(null);
  setEditingItem({ title: "", author: "", category: "", status: "" });
};


5️⃣ Delete Item

const deleteItem = (id) => {
  const updated = itemsArray.filter(item => item.id !== id);
  setItemsArray(updated);
  localStorage.setItem("itemsArray", JSON.stringify(updated));
};


6️⃣ Notes / Tips

-> Always use controlled inputs: value={state} onChange={e => setState({...state, field: e.target.value})}

-> Conditional rendering for edit: Only show inputs for the item being edited (editingId === item.id)

-> Persist changes to localStorage after every CRUD operation.

-> Validation: Can use a state object like { title: "", author: "" } to show error messages.

-> Consistent naming: Helps remember which state does what (itemsArray, newItem, editingItem)


✅ Memory Trick

Think of CRUD like managing a bookshelf:

_: Create → Put a book on the shelf

_: Read → Look at all the books on the shelf

_: Update → Take a book, change its details, put it back

_: Delete → Remove the book from the shelf